/**
 * Ahead-of-Time (AOT) Compiler
 * 
 * Statically compiles a Game Boy ROM to a standalone JavaScript file
 * that can run in any browser without the recompiler.
 */
import { ROM } from '../loader/ROMLoader';
import { CodeDatabase, analyzeBasicBlocksWithTargets, BasicBlock } from '../analyzer/BasicBlockAnalyzer';
import { transpileBlock } from '../recompiler/BlockTranspiler';
import { buildControlFlowGraph } from '../analyzer/ControlFlowGraph';
import { FlagAnalyzer } from '../analyzer/FlagAnalyzer';
import { RegisterAnalyzer } from '../analyzer/RegisterAnalyzer';
import { ConstantAnalyzer } from '../analyzer/ConstantAnalyzer';
import { EMBEDDED_JIT_CODE } from './EmbeddedJIT';

// Try to load BIOS if available
let bios: Uint8Array | null = null;
try {
  const biosModule = require('../bios.ts');
  bios = biosModule.bios;
  console.log('✓ BIOS loaded - Nintendo logo animation will be shown');
} catch (e: any) {
  console.log('ℹ BIOS not found - starting directly at 0x0100');
  // Uncomment for debugging: console.log('BIOS load error:', e.message);
}

export interface AOTCompilerOptions {
  romTitle: string;
  outputPath: string;
  includeDebugInfo?: boolean;
}

export class AOTCompiler {
  private database: CodeDatabase;
  private flagAnalyzer: FlagAnalyzer;
  private registerAnalyzer: RegisterAnalyzer;
  private constantAnalyzer: ConstantAnalyzer;
  
  constructor(private rom: ROM) {
    console.log('Analyzing ROM for AOT compilation...');
    
    // Perform static analysis
    this.database = analyzeBasicBlocksWithTargets(rom);
    const cfg = buildControlFlowGraph(this.database);
    
    console.log(`Found ${this.database.blocks.size} blocks`);
    
    // Run optimizations
    this.flagAnalyzer = new FlagAnalyzer(this.database.blocks, cfg);
    this.flagAnalyzer.analyze();
    
    this.registerAnalyzer = new RegisterAnalyzer(this.database.blocks, cfg);
    this.registerAnalyzer.analyze();
    
    this.constantAnalyzer = new ConstantAnalyzer(this.database.blocks, cfg);
    this.constantAnalyzer.analyze();
    
    console.log('Analysis complete');
  }
  
  /**
   * Compile entire ROM to standalone JavaScript
   */
  public compile(options: AOTCompilerOptions): string {
    console.log('Compiling blocks to JavaScript...');
    
    const blocks = Array.from(this.database.blocks.values());
    const compiledBlocks: string[] = [];
    
    for (const block of blocks) {
      try {
        const jsCode = this.compileBlock(block);
        compiledBlocks.push(jsCode);
      } catch (error) {
        console.warn(`Failed to compile block at 0x${block.startAddress.toString(16)}:`, error);
      }
    }
    
    console.log(`Compiled ${compiledBlocks.length} blocks`);
    
    // Generate complete standalone file
    return this.generateStandaloneFile(options, compiledBlocks);
  }
  
  /**
   * Compile a single block
   */
  private compileBlock(block: BasicBlock): string {
    const jsCode = transpileBlock(block, this.rom.data, {
      flagAnalyzer: this.flagAnalyzer,
      registerAnalyzer: this.registerAnalyzer,
      constantAnalyzer: this.constantAnalyzer,
    });
    
    // Wrap in function with all helper parameters
    const debugBlock = block.startAddress === 0x0293;
    return `
  // Block at 0x${block.startAddress.toString(16)} (${block.instructions.length} instructions)
  blocks[0x${block.startAddress.toString(16)}] = function(state, mmu, inc8, dec8, add8, adc8, sub8, sbc8, and8, xor8, or8, cp8, addHL, bit, set, res, swap, daa, sla, sra, srl, rlc, rrc, rl, rr) {
    ${debugBlock ? 'if (typeof window !== "undefined" && window.debugCount++ < 5) console.log("Block 0x293: B before=", state.B, "dec8=", typeof dec8);' : ''}
    let cycles = 0;
    ${jsCode}
    ${debugBlock ? 'if (typeof window !== "undefined" && window.debugCount <= 5) console.log("Block 0x293: B after=", state.B);' : ''}
  };`;
  }
  
  /**
   * Generate complete standalone JavaScript file
   */
  private generateStandaloneFile(options: AOTCompilerOptions, compiledBlocks: string[]): string {
    const romDataArray = Array.from(this.rom.data).join(',');
    const hasBios = bios !== null;
    const biosDataArray = hasBios ? Array.from(bios).join(',') : '';
    const startPC = hasBios ? '0x0000' : '0x0100';
    
    return `/**
 * ${options.romTitle} - AOT Compiled Game Boy ROM
 * 
 * Generated by Game Boy Dynamic Recompiler
 * Original ROM size: ${this.rom.data.length} bytes
 * Compiled blocks: ${compiledBlocks.length}
 */

(function() {
  'use strict';
  
  // Debug counters
  if (typeof window !== 'undefined') {
    window.debugCount = 0;
    window.ramBlockDebugCount = 0;
  }
  
  // ===== CPU State =====
  
  class CPUState {
    constructor() {
      this.A = 0x01;
      this.B = 0x00;
      this.C = 0x13;
      this.D = 0x00;
      this.E = 0xD8;
      this.H = 0x01;
      this.L = 0x4D;
      this.F = 0xB0;
      this.SP = 0xFFFE;
      this.PC = ${startPC};
      this.cycles = 0;
      this.halted = false;
      this.IME = false;
      this.enableIMEAfterNext = false;
    }
    
    getZ() { return (this.F & 0x80) !== 0; }
    setZ(v) { this.F = v ? (this.F | 0x80) : (this.F & 0x7F); }
    getN() { return (this.F & 0x40) !== 0; }
    setN(v) { this.F = v ? (this.F | 0x40) : (this.F & 0xBF); }
    getH() { return (this.F & 0x20) !== 0; }
    setH(v) { this.F = v ? (this.F | 0x20) : (this.F & 0xDF); }
    getC() { return (this.F & 0x10) !== 0; }
    setC(v) { this.F = v ? (this.F | 0x10) : (this.F & 0xEF); }
    
    reset() {
      this.A = 0x01; this.B = 0x00; this.C = 0x13; this.D = 0x00;
      this.E = 0xD8; this.H = 0x01; this.L = 0x4D; this.F = 0xB0;
      this.SP = 0xFFFE; this.PC = ${startPC};
      this.cycles = 0; this.halted = false; this.IME = false;
      this.enableIMEAfterNext = false;
    }
  }
  
  // ===== Memory Management Unit =====
  
  class MMU {
    constructor(romData, biosData) {
      this.rom = new Uint8Array(romData);
      this.bios = biosData ? new Uint8Array(biosData) : null;
      this.biosEnabled = !!biosData;  // BIOS is mapped only if provided
      this.vram = new Uint8Array(0x2000);
      this.wram = new Uint8Array(0x2000);
      this.oam = new Uint8Array(0xA0);
      this.io = new Uint8Array(0x80);
      this.hram = new Uint8Array(0x7F);
    }
    
    read8(addr) {
      // BIOS is mapped at 0x00-0xFF until disabled
      if (addr < 0x0100 && this.biosEnabled && this.bios) return this.bios[addr];
      if (addr < 0x8000) return this.rom[addr];
      if (addr < 0xA000) return this.vram[addr - 0x8000];
      if (addr < 0xC000) return 0xFF;
      if (addr < 0xE000) return this.wram[addr - 0xC000];
      if (addr < 0xFE00) return this.wram[addr - 0xE000];
      if (addr < 0xFEA0) return this.oam[addr - 0xFE00];
      if (addr < 0xFF00) return 0xFF;
      if (addr < 0xFF80) return this.io[addr - 0xFF00];
      if (addr < 0xFFFF) return this.hram[addr - 0xFF80];
      return this.io[0x7F];
    }
    
    write8(addr, value) {
      value &= 0xFF;
      if (addr < 0x8000) return;
      if (addr < 0xA000) { this.vram[addr - 0x8000] = value; return; }
      if (addr < 0xC000) return;
      if (addr < 0xE000) { this.wram[addr - 0xC000] = value; return; }
      if (addr < 0xFE00) { this.wram[addr - 0xE000] = value; return; }
      if (addr < 0xFEA0) { this.oam[addr - 0xFE00] = value; return; }
      if (addr < 0xFF00) return;
      if (addr < 0xFF80) {
        // Writing to 0xFF50 unmaps the BIOS
        if (addr === 0xFF50 && value !== 0) {
          this.biosEnabled = false;
          console.log('[BIOS] Unmapped - jumping to cartridge at 0x0100');
        }
        // Log LCDC writes
        if (addr === 0xFF40) {
          const oldValue = this.io[0x40] || 0;
          console.log('[LCDC] Write 0x' + value.toString(16).padStart(2, '0') + ' (was 0x' + oldValue.toString(16).padStart(2, '0') + ') - LCD=' + (value & 0x80 ? 'ON' : 'OFF') + ' BG=' + (value & 0x01 ? 'ON' : 'OFF'));
        }
        this.io[addr - 0xFF00] = value;
        return;
      }
      if (addr < 0xFFFF) { this.hram[addr - 0xFF80] = value; return; }
      // Log IE writes
      if (addr === 0xFFFF) {
        const oldValue = this.io[0x7F] || 0;
        console.log('[IE] Write 0x' + value.toString(16).padStart(2, '0') + ' (was 0x' + oldValue.toString(16).padStart(2, '0') + ') - VBlank=' + (value & 0x01 ? 'ON' : 'OFF'));
      }
      this.io[0x7F] = value;
    }
    
    read16(addr) {
      return this.read8(addr) | (this.read8(addr + 1) << 8);
    }
    
    write16(addr, value) {
      this.write8(addr, value & 0xFF);
      this.write8(addr + 1, (value >> 8) & 0xFF);
    }
    
    getIO(offset) { return this.io[offset] || 0; }
    setIO(offset, value) { this.io[offset] = value & 0xFF; }
    getVRAM() { return this.vram; }
    getOAM() { return this.oam; }
  }
  
  // ===== PPU =====
  
  class PPU {
    constructor(mmu) {
      this.mmu = mmu;
      this.frameBuffer = new Uint8ClampedArray(160 * 144 * 4);
      this.scanline = 0;
      this.scanlineCycles = 0;
      this.bgPalette = [255, 192, 96, 0];
      
      for (let i = 0; i < this.frameBuffer.length; i += 4) {
        this.frameBuffer[i] = 255;
        this.frameBuffer[i + 1] = 255;
        this.frameBuffer[i + 2] = 255;
        this.frameBuffer[i + 3] = 255;
      }
    }
    
    step(cycles) {
      this.scanlineCycles += cycles;
      
      if (this.scanlineCycles >= 456) {
        this.scanlineCycles -= 456;
        this.scanline++;
        
        if (this.scanline < 144) {
          this.renderScanline();
        } else if (this.scanline === 144) {
          const IF = this.mmu.getIO(0x0F);
          this.mmu.setIO(0x0F, IF | 0x01);
          return true;
        } else if (this.scanline > 153) {
          this.scanline = 0;
        }
      }
      
      this.mmu.setIO(0x44, this.scanline);
      return false;
    }
    
    renderScanline() {
      const lcdc = this.mmu.getIO(0x40);
      if ((lcdc & 0x01) === 0) return;
      
      const scrollY = this.mmu.getIO(0x42);
      const scrollX = this.mmu.getIO(0x43);
      const bgTileData = (lcdc & 0x10) ? 0x8000 : 0x8800;
      const bgTileMap = (lcdc & 0x08) ? 0x9C00 : 0x9800;
      
      const y = (this.scanline + scrollY) & 0xFF;
      const tileRow = (y >> 3) & 31;
      const tileY = y & 7;
      
      for (let x = 0; x < 160; x++) {
        const scrolledX = (x + scrollX) & 0xFF;
        const tileCol = (scrolledX >> 3) & 31;
        const tileX = scrolledX & 7;
        
        const tileMapAddr = bgTileMap + tileRow * 32 + tileCol;
        const tileNum = this.mmu.getVRAM()[tileMapAddr - 0x8000];
        
        let tileDataAddr;
        if (bgTileData === 0x8000) {
          tileDataAddr = 0x8000 + tileNum * 16;
        } else {
          const signed = tileNum < 128 ? tileNum : tileNum - 256;
          tileDataAddr = 0x9000 + signed * 16;
        }
        
        const line = tileY * 2;
        const byte1 = this.mmu.getVRAM()[tileDataAddr - 0x8000 + line];
        const byte2 = this.mmu.getVRAM()[tileDataAddr - 0x8000 + line + 1];
        
        const bit = 7 - tileX;
        const colorBit = ((byte2 >> bit) & 1) << 1 | ((byte1 >> bit) & 1);
        const color = this.bgPalette[colorBit];
        
        const offset = (this.scanline * 160 + x) * 4;
        this.frameBuffer[offset] = color;
        this.frameBuffer[offset + 1] = color;
        this.frameBuffer[offset + 2] = color;
        this.frameBuffer[offset + 3] = 255;
      }
    }
    
    getFrameBuffer() { return this.frameBuffer; }
    reset() { this.scanline = 0; this.scanlineCycles = 0; }
  }
  
  // ===== Helper Functions =====
  
  const helpers = {
    inc8: (state, val) => {
      const result = (val + 1) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH((val & 0xF) === 0xF);
      return result;
    },
    
    dec8: (state, val) => {
      const result = (val - 1) & 0xFF;
      state.setZ(result === 0);
      state.setN(true);
      state.setH((val & 0xF) === 0);
      return result;
    },
    
    add8: (state, a, b) => {
      const result = (a + b) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH((a & 0xF) + (b & 0xF) > 0xF);
      state.setC(a + b > 0xFF);
      return result;
    },
    
    adc8: (state, a, b) => {
      const carry = state.getC() ? 1 : 0;
      const result = (a + b + carry) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH((a & 0xF) + (b & 0xF) + carry > 0xF);
      state.setC(a + b + carry > 0xFF);
      return result;
    },
    
    sub8: (state, a, b) => {
      const result = (a - b) & 0xFF;
      state.setZ(result === 0);
      state.setN(true);
      state.setH((a & 0xF) < (b & 0xF));
      state.setC(a < b);
      return result;
    },
    
    sbc8: (state, a, b) => {
      const carry = state.getC() ? 1 : 0;
      const result = (a - b - carry) & 0xFF;
      state.setZ(result === 0);
      state.setN(true);
      state.setH((a & 0xF) < (b & 0xF) + carry);
      state.setC(a < b + carry);
      return result;
    },
    
    and8: (state, a, b) => {
      const result = a & b;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(true);
      state.setC(false);
      return result;
    },
    
    xor8: (state, a, b) => {
      const result = a ^ b;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(false);
      return result;
    },
    
    or8: (state, a, b) => {
      const result = a | b;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(false);
      return result;
    },
    
    cp8: (state, a, b) => {
      state.setZ(a === b);
      state.setN(true);
      state.setH((a & 0xF) < (b & 0xF));
      state.setC(a < b);
    },
    
    addHL: (state, hl, val) => {
      const result = (hl + val) & 0xFFFF;
      state.setN(false);
      state.setH((hl & 0xFFF) + (val & 0xFFF) > 0xFFF);
      state.setC(hl + val > 0xFFFF);
      return result;
    },
    
    bit: (state, bitNum, val) => {
      const result = (val >> bitNum) & 1;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(true);
    },
    
    set: (state, bitNum, val) => val | (1 << bitNum),
    res: (state, bitNum, val) => val & ~(1 << bitNum),
    
    swap: (state, val) => {
      const result = ((val & 0x0F) << 4) | ((val & 0xF0) >> 4);
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(false);
      return result;
    },
    
    daa: (state) => {
      let a = state.A;
      if (!state.getN()) {
        if (state.getC() || a > 0x99) {
          a += 0x60;
          state.setC(true);
        }
        if (state.getH() || (a & 0x0F) > 0x09) {
          a += 0x06;
        }
      } else {
        if (state.getC()) a -= 0x60;
        if (state.getH()) a -= 0x06;
      }
      a &= 0xFF;
      state.A = a;
      state.setZ(a === 0);
      state.setH(false);
    },
    
    sla: (state, val) => {
      const carry = (val >> 7) & 1;
      const result = (val << 1) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(carry === 1);
      return result;
    },
    
    sra: (state, val) => {
      const carry = val & 1;
      const result = ((val >> 1) | (val & 0x80)) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(carry === 1);
      return result;
    },
    
    srl: (state, val) => {
      const carry = val & 1;
      const result = (val >> 1) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(carry === 1);
      return result;
    },
    
    rlc: (state, val) => {
      const carry = (val >> 7) & 1;
      const result = ((val << 1) | carry) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(carry === 1);
      return result;
    },
    
    rrc: (state, val) => {
      const carry = val & 1;
      const result = ((val >> 1) | (carry << 7)) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(carry === 1);
      return result;
    },
    
    rl: (state, val) => {
      const oldCarry = state.getC() ? 1 : 0;
      const carry = (val >> 7) & 1;
      const result = ((val << 1) | oldCarry) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(carry === 1);
      return result;
    },
    
    rr: (state, val) => {
      const oldCarry = state.getC() ? 1 : 0;
      const carry = val & 1;
      const result = ((val >> 1) | (oldCarry << 7)) & 0xFF;
      state.setZ(result === 0);
      state.setN(false);
      state.setH(false);
      state.setC(carry === 1);
      return result;
    },
  };
  
  // Destructure helpers into global scope for blocks
  const { inc8, dec8, add8, adc8, sub8, sbc8, and8, xor8, or8, cp8, addHL, bit, set, res, swap, daa, sla, sra, srl, rlc, rrc, rl, rr } = helpers;
  
${EMBEDDED_JIT_CODE}
  
  // ===== ROM Data =====
  
  const romData = new Uint8Array([${romDataArray}]);
  ${hasBios ? `const biosData = new Uint8Array([${biosDataArray}]);` : 'const biosData = null;'}
  
  // ===== Compiled Blocks =====
  
  const blocks = {};
  
${compiledBlocks.join('\n')}
  
  // ===== Emulator =====
  
  class Emulator {
    constructor() {
      this.state = new CPUState();
      this.mmu = new MMU(romData, biosData);
      this.ppu = new PPU(this.mmu);
      this.running = false;
    }
    
    executeBlock() {
      // Handle interrupts if enabled
      if (this.state.IME) {
        const IF = this.mmu.getIO(0x0F); // Interrupt flags
        const IE = this.mmu.getIO(0xFF); // Interrupt enable
        const triggered = IF & IE & 0x1F;
        
        if (triggered) {
          // Service highest priority interrupt
          this.state.IME = false;
          this.state.halted = false;
          
          // Push PC onto stack
          this.state.SP = (this.state.SP - 2) & 0xFFFF;
          this.mmu.write16(this.state.SP, this.state.PC);
          
          // Jump to interrupt handler
          if (triggered & 0x01) {
            // V-Blank
            this.mmu.setIO(0x0F, IF & ~0x01);
            this.state.PC = 0x0040;
            this.state.cycles += 20;
            return;
          } else if (triggered & 0x02) {
            // LCD STAT
            this.mmu.setIO(0x0F, IF & ~0x02);
            this.state.PC = 0x0048;
            this.state.cycles += 20;
            return;
          } else if (triggered & 0x04) {
            // Timer
            this.mmu.setIO(0x0F, IF & ~0x04);
            this.state.PC = 0x0050;
            this.state.cycles += 20;
            return;
          } else if (triggered & 0x08) {
            // Serial
            this.mmu.setIO(0x0F, IF & ~0x08);
            this.state.PC = 0x0058;
            this.state.cycles += 20;
            return;
          } else if (triggered & 0x10) {
            // Joypad
            this.mmu.setIO(0x0F, IF & ~0x10);
            this.state.PC = 0x0060;
            this.state.cycles += 20;
            return;
          }
        }
      }
      
      // Handle EI delay
      if (this.state.enableIMEAfterNext) {
        this.state.IME = true;
        this.state.enableIMEAfterNext = false;
      }
      
      const pc = this.state.PC;
      let block = blocks[pc];
      
      if (!block) {
        // Try JIT compilation
        block = jitCompileBlock(pc, romData, this.mmu, this.state);
        
        if (block) {
          // Cache the compiled block
          blocks[pc] = block;
        } else {
          // JIT failed - halt
          console.error(\`Cannot execute block at 0x\${pc.toString(16)} - not AOT compiled and JIT failed\`);
          this.state.halted = true;
          return;
        }
      }
      
      const result = block(this.state, this.mmu, inc8, dec8, add8, adc8, sub8, sbc8, and8, xor8, or8, cp8, addHL, bit, set, res, swap, daa, sla, sra, srl, rlc, rrc, rl, rr);
      this.state.cycles += result.cycles;
      
      if (result.exit === 'halt') {
        this.state.halted = true;
      } else if (result.nextBlock !== null) {
        this.state.PC = result.nextBlock;
      }
      
      this.ppu.step(result.cycles);
    }
    
    executeFrame() {
      const targetCycles = this.state.cycles + 70224;
      
      while (this.state.cycles < targetCycles && !this.state.halted) {
        this.executeBlock();
      }
    }
    
    run() {
      if (!this.running) return;
      
      this.executeFrame();
      requestAnimationFrame(() => this.run());
    }
    
    start() {
      this.running = true;
      this.run();
    }
    
    stop() {
      this.running = false;
    }
    
    reset() {
      this.state.reset();
      this.ppu.reset();
    }
  }
  
  // ===== Main =====
  
  const api = {
    Emulator,
    romTitle: '${options.romTitle}',
    romSize: ${this.rom.data.length},
    blocksCompiled: ${compiledBlocks.length}
  };
  
  // Export for both browser and Node.js
  if (typeof window !== 'undefined') {
    window.GameBoyEmulator = api;
    window.getMissingInstructionsSummary = getMissingInstructionsSummary;
  } else if (typeof global !== 'undefined') {
    global.GameBoyEmulator = api;
    global.getMissingInstructionsSummary = getMissingInstructionsSummary;
  }
  
  console.log('${options.romTitle} loaded - ${compiledBlocks.length} blocks compiled');
  
})();
`;
  }
}
